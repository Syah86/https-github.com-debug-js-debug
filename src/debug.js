
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */
exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {
  s: String,
  i: function (v) {
    v = Number(v);
    return v - (v % 1);
  },
  d: Number,
  f: Number
};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Formats a sequence of arguments.
 * @api private
 */

function formatInlineArgs(dbg, args) {
  args[0] = exports.coerce(args[0]);

  if ('string' !== typeof args[0]) {
    // anything else let's inspect with %O
    args.unshift('%O');
  }

  var index = 0;
  args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
    // if we encounter an escaped % then don't increase the array index
    if (match === '%%') return match;
    index++;
    var formatter = exports.formatters[format];
    if ('function' === typeof formatter) {
      var val = args[index];
      match = formatter.call(dbg, val);

      // now we need to remove `args[index]` since it's inlined in the `format`
      args.splice(index, 1);
      index--;
    }
    return match;
  });

  return args;
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debugHandle(rawArgs, section) {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(rawArgs.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = rawArgs[i];
    }

    // apply any `formatters` transformations
    formatInlineArgs(self, args);

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args, section);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  function debug() {
    debugHandle(arguments);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  debug.begin = function () {
    // hrtime() can return whatever it wants with no arguments;
    // however, it must return a float when called with a second parameter;
    // that float must be the delta time in milliseconds.
    var args = arguments;
    var beginTime = exports.hrtime();
    var ended = false;

    var mark = function (title, extraArgs) {
      if (ended) {
        return;
      }

      section.title = title;
      section.deltaTime = exports.hrtime(beginTime);
      if (extraArgs.length) {
        var leftArgs = formatInlineArgs(debug, [].slice.call(args));
        var newArgs;
        if (extraArgs.length > 0) {
          var rightArgs = formatInlineArgs(debug, [].slice.call(extraArgs));
          newArgs = leftArgs.concat(['::']).concat(rightArgs)
        } else {
          newArgs = leftArgs;
        }
        debugHandle(newArgs, section);
      } else {
        debugHandle(args, section);
      }
      return section;
    }

    var section = {
      title: '[begin]',
      end: function () {
        try {
          return mark('[end]', arguments);
        } finally {
          ended = true;
        }
      },
      mark: function () {
        return mark('[mark]', arguments);
      }
    };

    debugHandle(args, section);
    section.complete = true;

    return section;
  };

  debug.time = function () {
    var args = [].slice.call(arguments);
    if (args.length < 2) {
      throw new Error('debug.time() takes at least a debug string and a function');
    }

    var fn = args.pop();
    if (typeof fn !== 'function') {
      throw new Error('the last argument to debug.time() must be a function');
    }

    var isPromise = false;
    var section = debug.begin.apply(debug, args);
    try {
      var result = fn(section);

      if (typeof Promise === 'function' && result instanceof Promise) { // eslint-disable-line no-undef
        isPromise = true;
        result.then(function () {
          section.end();
        });
      }

      return result;
    } finally {
      if (!isPromise) {
        section.end();
      }
    }
  };

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
